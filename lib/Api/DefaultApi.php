<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * openText API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.1.0
 * Contact: smeyer.ilias@gmx.de
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.4
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiV1AuthGet
     *
     * Gets information on the currently authenticated user.
     *
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (optional)
     * @param  bool $perspective Determines if the landing page perspective will be included in the response. (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;.  The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not).  This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiV1AuthGet($fields = null, $expand = null, $expand_fields = null, $perspective = null, $suppress_response_codes = null)
    {
        $this->apiV1AuthGetWithHttpInfo($fields, $expand, $expand_fields, $perspective, $suppress_response_codes);
    }

    /**
     * Operation apiV1AuthGetWithHttpInfo
     *
     * Gets information on the currently authenticated user.
     *
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (optional)
     * @param  bool $perspective Determines if the landing page perspective will be included in the response. (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;.  The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not).  This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1AuthGetWithHttpInfo($fields = null, $expand = null, $expand_fields = null, $perspective = null, $suppress_response_codes = null)
    {
        $returnType = '';
        $request = $this->apiV1AuthGetRequest($fields, $expand, $expand_fields, $perspective, $suppress_response_codes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiV1AuthGetAsync
     *
     * Gets information on the currently authenticated user.
     *
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (optional)
     * @param  bool $perspective Determines if the landing page perspective will be included in the response. (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;.  The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not).  This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1AuthGetAsync($fields = null, $expand = null, $expand_fields = null, $perspective = null, $suppress_response_codes = null)
    {
        return $this->apiV1AuthGetAsyncWithHttpInfo($fields, $expand, $expand_fields, $perspective, $suppress_response_codes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1AuthGetAsyncWithHttpInfo
     *
     * Gets information on the currently authenticated user.
     *
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (optional)
     * @param  bool $perspective Determines if the landing page perspective will be included in the response. (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;.  The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not).  This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1AuthGetAsyncWithHttpInfo($fields = null, $expand = null, $expand_fields = null, $perspective = null, $suppress_response_codes = null)
    {
        $returnType = '';
        $request = $this->apiV1AuthGetRequest($fields, $expand, $expand_fields, $perspective, $suppress_response_codes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1AuthGet'
     *
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (optional)
     * @param  bool $perspective Determines if the landing page perspective will be included in the response. (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;.  The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not).  This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV1AuthGetRequest($fields = null, $expand = null, $expand_fields = null, $perspective = null, $suppress_response_codes = null)
    {

        $resourcePath = '/api/v1/auth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand);
        }
        // query params
        if ($expand_fields !== null) {
            $queryParams['expand_fields'] = ObjectSerializer::toQueryValue($expand_fields);
        }
        // query params
        if ($perspective !== null) {
            $queryParams['perspective'] = ObjectSerializer::toQueryValue($perspective);
        }
        // query params
        if ($suppress_response_codes !== null) {
            $queryParams['suppress_response_codes'] = ObjectSerializer::toQueryValue($suppress_response_codes);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV1AuthPost
     *
     * Authenticate user
     *
     * @param  string $username Login name (required)
     * @param  string $password Login password (required)
     * @param  string $domain Login domain (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AuthenticationInfo
     */
    public function apiV1AuthPost($username, $password, $domain)
    {
        list($response) = $this->apiV1AuthPostWithHttpInfo($username, $password, $domain);
        return $response;
    }

    /**
     * Operation apiV1AuthPostWithHttpInfo
     *
     * Authenticate user
     *
     * @param  string $username Login name (required)
     * @param  string $password Login password (required)
     * @param  string $domain Login domain (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AuthenticationInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1AuthPostWithHttpInfo($username, $password, $domain)
    {
        $returnType = '\Swagger\Client\Model\AuthenticationInfo';
        $request = $this->apiV1AuthPostRequest($username, $password, $domain);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AuthenticationInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV1AuthPostAsync
     *
     * Authenticate user
     *
     * @param  string $username Login name (required)
     * @param  string $password Login password (required)
     * @param  string $domain Login domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1AuthPostAsync($username, $password, $domain)
    {
        return $this->apiV1AuthPostAsyncWithHttpInfo($username, $password, $domain)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1AuthPostAsyncWithHttpInfo
     *
     * Authenticate user
     *
     * @param  string $username Login name (required)
     * @param  string $password Login password (required)
     * @param  string $domain Login domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1AuthPostAsyncWithHttpInfo($username, $password, $domain)
    {
        $returnType = '\Swagger\Client\Model\AuthenticationInfo';
        $request = $this->apiV1AuthPostRequest($username, $password, $domain);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1AuthPost'
     *
     * @param  string $username Login name (required)
     * @param  string $password Login password (required)
     * @param  string $domain Login domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV1AuthPostRequest($username, $password, $domain)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling apiV1AuthPost'
            );
        }
        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling apiV1AuthPost'
            );
        }
        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling apiV1AuthPost'
            );
        }

        $resourcePath = '/api/v1/auth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($username !== null) {
            $formParams['username'] = ObjectSerializer::toFormValue($username);
        }
        // form params
        if ($password !== null) {
            $formParams['password'] = ObjectSerializer::toFormValue($password);
        }
        // form params
        if ($domain !== null) {
            $formParams['domain'] = ObjectSerializer::toFormValue($domain);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNode
     *
     * Get node information
     *
     * @param  string $id Node ID (required)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (required)
     * @param  int $reference_id Reference node ID (required)
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  bool $metadata Returns metadata (data type, field length, min/max values, etc.) about data, which will be returned under results.metadata / metadata_map / metadata_order. This is an empty parameter, thus no value is required (e.g. ?metadata). (optional)
     * @param  bool $perspective Determines if the perspective for the node will be included in the response. This is an empty parameter, thus no value is required (e.g. ?perspective). (optional)
     * @param  bool $state Returns the metadata state token for data (used for edit conflict resolution), which will be returned under results.state. This is an empty parameter, thus no value is required (e.g. ?state). (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;. The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not). This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     * @param  string $actions Retrieve actions for the node. This is similar to &#39;commands&#39; for v1 (E.g. actions&#x3D;delete&amp;actions&#x3D;open). Note: For best performance minimize the number of actions requested. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getNode($id, $expand_fields, $reference_id, $fields = null, $expand = null, $metadata = null, $perspective = null, $state = null, $suppress_response_codes = null, $actions = null)
    {
        $this->getNodeWithHttpInfo($id, $expand_fields, $reference_id, $fields, $expand, $metadata, $perspective, $state, $suppress_response_codes, $actions);
    }

    /**
     * Operation getNodeWithHttpInfo
     *
     * Get node information
     *
     * @param  string $id Node ID (required)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (required)
     * @param  int $reference_id Reference node ID (required)
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  bool $metadata Returns metadata (data type, field length, min/max values, etc.) about data, which will be returned under results.metadata / metadata_map / metadata_order. This is an empty parameter, thus no value is required (e.g. ?metadata). (optional)
     * @param  bool $perspective Determines if the perspective for the node will be included in the response. This is an empty parameter, thus no value is required (e.g. ?perspective). (optional)
     * @param  bool $state Returns the metadata state token for data (used for edit conflict resolution), which will be returned under results.state. This is an empty parameter, thus no value is required (e.g. ?state). (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;. The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not). This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     * @param  string $actions Retrieve actions for the node. This is similar to &#39;commands&#39; for v1 (E.g. actions&#x3D;delete&amp;actions&#x3D;open). Note: For best performance minimize the number of actions requested. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodeWithHttpInfo($id, $expand_fields, $reference_id, $fields = null, $expand = null, $metadata = null, $perspective = null, $state = null, $suppress_response_codes = null, $actions = null)
    {
        $returnType = '';
        $request = $this->getNodeRequest($id, $expand_fields, $reference_id, $fields, $expand, $metadata, $perspective, $state, $suppress_response_codes, $actions);

        \ilLoggerFactory::getLogger('root')->dump($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getNodeAsync
     *
     * Get node information
     *
     * @param  string $id Node ID (required)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (required)
     * @param  int $reference_id Reference node ID (required)
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  bool $metadata Returns metadata (data type, field length, min/max values, etc.) about data, which will be returned under results.metadata / metadata_map / metadata_order. This is an empty parameter, thus no value is required (e.g. ?metadata). (optional)
     * @param  bool $perspective Determines if the perspective for the node will be included in the response. This is an empty parameter, thus no value is required (e.g. ?perspective). (optional)
     * @param  bool $state Returns the metadata state token for data (used for edit conflict resolution), which will be returned under results.state. This is an empty parameter, thus no value is required (e.g. ?state). (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;. The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not). This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     * @param  string $actions Retrieve actions for the node. This is similar to &#39;commands&#39; for v1 (E.g. actions&#x3D;delete&amp;actions&#x3D;open). Note: For best performance minimize the number of actions requested. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAsync($id, $expand_fields, $reference_id, $fields = null, $expand = null, $metadata = null, $perspective = null, $state = null, $suppress_response_codes = null, $actions = null)
    {
        return $this->getNodeAsyncWithHttpInfo($id, $expand_fields, $reference_id, $fields, $expand, $metadata, $perspective, $state, $suppress_response_codes, $actions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodeAsyncWithHttpInfo
     *
     * Get node information
     *
     * @param  string $id Node ID (required)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (required)
     * @param  int $reference_id Reference node ID (required)
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  bool $metadata Returns metadata (data type, field length, min/max values, etc.) about data, which will be returned under results.metadata / metadata_map / metadata_order. This is an empty parameter, thus no value is required (e.g. ?metadata). (optional)
     * @param  bool $perspective Determines if the perspective for the node will be included in the response. This is an empty parameter, thus no value is required (e.g. ?perspective). (optional)
     * @param  bool $state Returns the metadata state token for data (used for edit conflict resolution), which will be returned under results.state. This is an empty parameter, thus no value is required (e.g. ?state). (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;. The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not). This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     * @param  string $actions Retrieve actions for the node. This is similar to &#39;commands&#39; for v1 (E.g. actions&#x3D;delete&amp;actions&#x3D;open). Note: For best performance minimize the number of actions requested. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAsyncWithHttpInfo($id, $expand_fields, $reference_id, $fields = null, $expand = null, $metadata = null, $perspective = null, $state = null, $suppress_response_codes = null, $actions = null)
    {
        $returnType = '';
        $request = $this->getNodeRequest($id, $expand_fields, $reference_id, $fields, $expand, $metadata, $perspective, $state, $suppress_response_codes, $actions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNode'
     *
     * @param  string $id Node ID (required)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (required)
     * @param  int $reference_id Reference node ID (required)
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  bool $metadata Returns metadata (data type, field length, min/max values, etc.) about data, which will be returned under results.metadata / metadata_map / metadata_order. This is an empty parameter, thus no value is required (e.g. ?metadata). (optional)
     * @param  bool $perspective Determines if the perspective for the node will be included in the response. This is an empty parameter, thus no value is required (e.g. ?perspective). (optional)
     * @param  bool $state Returns the metadata state token for data (used for edit conflict resolution), which will be returned under results.state. This is an empty parameter, thus no value is required (e.g. ?state). (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;. The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not). This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     * @param  string $actions Retrieve actions for the node. This is similar to &#39;commands&#39; for v1 (E.g. actions&#x3D;delete&amp;actions&#x3D;open). Note: For best performance minimize the number of actions requested. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodeRequest($id, $expand_fields, $reference_id, $fields = null, $expand = null, $metadata = null, $perspective = null, $state = null, $suppress_response_codes = null, $actions = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getNode'
            );
        }
        // verify the required parameter 'expand_fields' is set
        if ($expand_fields === null || (is_array($expand_fields) && count($expand_fields) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expand_fields when calling getNode'
            );
        }
        // verify the required parameter 'reference_id' is set
        if ($reference_id === null || (is_array($reference_id) && count($reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reference_id when calling getNode'
            );
        }

        $resourcePath = '/api/v1/nodes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = ObjectSerializer::toQueryValue($metadata);
        }
        // query params
        if ($perspective !== null) {
            $queryParams['perspective'] = ObjectSerializer::toQueryValue($perspective);
        }
        // query params
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state);
        }
        // query params
        if ($suppress_response_codes !== null) {
            $queryParams['suppress_response_codes'] = ObjectSerializer::toQueryValue($suppress_response_codes);
        }
        // query params
        if ($actions !== null) {
            $queryParams['actions'] = ObjectSerializer::toQueryValue($actions);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($expand_fields !== null) {
            $resourcePath = str_replace(
                '{' . 'expand_fields' . '}',
                ObjectSerializer::toPathValue($expand_fields),
                $resourcePath
            );
        }
        // path params
        if ($reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'reference_id' . '}',
                ObjectSerializer::toPathValue($reference_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('OTCSTicket');
        if ($apiKey !== null) {
            $headers['OTCSTicket'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}

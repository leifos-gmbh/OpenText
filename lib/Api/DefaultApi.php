<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * openText API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.1.0
 * Contact: smeyer.ilias@gmx.de
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.12
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addDocument
     *
     * Add a new document node
     *
     * @param  int $type type (required)
     * @param  int $parent_id parent_id (required)
     * @param  string $name name (required)
     * @param  \SplFileObject $file file (required)
     * @param  string $description description (optional)
     * @param  bool $advanced_versioning advanced_versioning (optional)
     * @param  \DateTime $external_create_date external_create_date (optional)
     * @param  \DateTime $external_modify_date external_modify_date (optional)
     * @param  string $external_source external_source (optional)
     * @param  string $external_identity external_identity (optional)
     * @param  string $external_identity_type external_identity_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\V2ResponseElementPost
     */
    public function addDocument($type, $parent_id, $name, $file, $description = null, $advanced_versioning = null, $external_create_date = null, $external_modify_date = null, $external_source = null, $external_identity = null, $external_identity_type = null)
    {
        list($response) = $this->addDocumentWithHttpInfo($type, $parent_id, $name, $file, $description, $advanced_versioning, $external_create_date, $external_modify_date, $external_source, $external_identity, $external_identity_type);
        return $response;
    }

    /**
     * Operation addDocumentWithHttpInfo
     *
     * Add a new document node
     *
     * @param  int $type (required)
     * @param  int $parent_id (required)
     * @param  string $name (required)
     * @param  \SplFileObject $file (required)
     * @param  string $description (optional)
     * @param  bool $advanced_versioning (optional)
     * @param  \DateTime $external_create_date (optional)
     * @param  \DateTime $external_modify_date (optional)
     * @param  string $external_source (optional)
     * @param  string $external_identity (optional)
     * @param  string $external_identity_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\V2ResponseElementPost, HTTP status code, HTTP response headers (array of strings)
     */
    public function addDocumentWithHttpInfo($type, $parent_id, $name, $file, $description = null, $advanced_versioning = null, $external_create_date = null, $external_modify_date = null, $external_source = null, $external_identity = null, $external_identity_type = null)
    {
        $returnType = '\Swagger\Client\Model\V2ResponseElementPost';
        $request = $this->addDocumentRequest($type, $parent_id, $name, $file, $description, $advanced_versioning, $external_create_date, $external_modify_date, $external_source, $external_identity, $external_identity_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\V2ResponseElementPost',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addDocumentAsync
     *
     * Add a new document node
     *
     * @param  int $type (required)
     * @param  int $parent_id (required)
     * @param  string $name (required)
     * @param  \SplFileObject $file (required)
     * @param  string $description (optional)
     * @param  bool $advanced_versioning (optional)
     * @param  \DateTime $external_create_date (optional)
     * @param  \DateTime $external_modify_date (optional)
     * @param  string $external_source (optional)
     * @param  string $external_identity (optional)
     * @param  string $external_identity_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addDocumentAsync($type, $parent_id, $name, $file, $description = null, $advanced_versioning = null, $external_create_date = null, $external_modify_date = null, $external_source = null, $external_identity = null, $external_identity_type = null)
    {
        return $this->addDocumentAsyncWithHttpInfo($type, $parent_id, $name, $file, $description, $advanced_versioning, $external_create_date, $external_modify_date, $external_source, $external_identity, $external_identity_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addDocumentAsyncWithHttpInfo
     *
     * Add a new document node
     *
     * @param  int $type (required)
     * @param  int $parent_id (required)
     * @param  string $name (required)
     * @param  \SplFileObject $file (required)
     * @param  string $description (optional)
     * @param  bool $advanced_versioning (optional)
     * @param  \DateTime $external_create_date (optional)
     * @param  \DateTime $external_modify_date (optional)
     * @param  string $external_source (optional)
     * @param  string $external_identity (optional)
     * @param  string $external_identity_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addDocumentAsyncWithHttpInfo($type, $parent_id, $name, $file, $description = null, $advanced_versioning = null, $external_create_date = null, $external_modify_date = null, $external_source = null, $external_identity = null, $external_identity_type = null)
    {
        $returnType = '\Swagger\Client\Model\V2ResponseElementPost';
        $request = $this->addDocumentRequest($type, $parent_id, $name, $file, $description, $advanced_versioning, $external_create_date, $external_modify_date, $external_source, $external_identity, $external_identity_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addDocument'
     *
     * @param  int $type (required)
     * @param  int $parent_id (required)
     * @param  string $name (required)
     * @param  \SplFileObject $file (required)
     * @param  string $description (optional)
     * @param  bool $advanced_versioning (optional)
     * @param  \DateTime $external_create_date (optional)
     * @param  \DateTime $external_modify_date (optional)
     * @param  string $external_source (optional)
     * @param  string $external_identity (optional)
     * @param  string $external_identity_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addDocumentRequest($type, $parent_id, $name, $file, $description = null, $advanced_versioning = null, $external_create_date = null, $external_modify_date = null, $external_source = null, $external_identity = null, $external_identity_type = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling addDocument'
            );
        }
        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling addDocument'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling addDocument'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling addDocument'
            );
        }

        $resourcePath = '/api/v2/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($type !== null) {
            $formParams['type'] = ObjectSerializer::toFormValue($type);
        }
        // form params
        if ($parent_id !== null) {
            $formParams['parent_id'] = ObjectSerializer::toFormValue($parent_id);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($advanced_versioning !== null) {
            $formParams['advanced_versioning'] = ObjectSerializer::toFormValue($advanced_versioning);
        }
        // form params
        if ($external_create_date !== null) {
            $formParams['external_create_date'] = ObjectSerializer::toFormValue($external_create_date);
        }
        // form params
        if ($external_modify_date !== null) {
            $formParams['external_modify_date'] = ObjectSerializer::toFormValue($external_modify_date);
        }
        // form params
        if ($external_source !== null) {
            $formParams['external_source'] = ObjectSerializer::toFormValue($external_source);
        }
        // form params
        if ($external_identity !== null) {
            $formParams['external_identity'] = ObjectSerializer::toFormValue($external_identity);
        }
        // form params
        if ($external_identity_type !== null) {
            $formParams['external_identity_type'] = ObjectSerializer::toFormValue($external_identity_type);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('OTCSTicket');
        if ($apiKey !== null) {
            $headers['OTCSTicket'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addFolder
     *
     * Add a new folder node
     *
     * @param  int $type Subtype of the node &#39;0&#39; for folder type (required)
     * @param  int $parent_id Parent node ID (required)
     * @param  string $name Name of the node (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CreateResponse
     */
    public function addFolder($type, $parent_id, $name)
    {
        list($response) = $this->addFolderWithHttpInfo($type, $parent_id, $name);
        return $response;
    }

    /**
     * Operation addFolderWithHttpInfo
     *
     * Add a new folder node
     *
     * @param  int $type Subtype of the node &#39;0&#39; for folder type (required)
     * @param  int $parent_id Parent node ID (required)
     * @param  string $name Name of the node (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CreateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addFolderWithHttpInfo($type, $parent_id, $name)
    {
        $returnType = '\Swagger\Client\Model\CreateResponse';
        $request = $this->addFolderRequest($type, $parent_id, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CreateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addFolderAsync
     *
     * Add a new folder node
     *
     * @param  int $type Subtype of the node &#39;0&#39; for folder type (required)
     * @param  int $parent_id Parent node ID (required)
     * @param  string $name Name of the node (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFolderAsync($type, $parent_id, $name)
    {
        return $this->addFolderAsyncWithHttpInfo($type, $parent_id, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addFolderAsyncWithHttpInfo
     *
     * Add a new folder node
     *
     * @param  int $type Subtype of the node &#39;0&#39; for folder type (required)
     * @param  int $parent_id Parent node ID (required)
     * @param  string $name Name of the node (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFolderAsyncWithHttpInfo($type, $parent_id, $name)
    {
        $returnType = '\Swagger\Client\Model\CreateResponse';
        $request = $this->addFolderRequest($type, $parent_id, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addFolder'
     *
     * @param  int $type Subtype of the node &#39;0&#39; for folder type (required)
     * @param  int $parent_id Parent node ID (required)
     * @param  string $name Name of the node (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addFolderRequest($type, $parent_id, $name)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling addFolder'
            );
        }
        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling addFolder'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling addFolder'
            );
        }

        $resourcePath = '/api/v1/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($type !== null) {
            $formParams['type'] = ObjectSerializer::toFormValue($type);
        }
        // form params
        if ($parent_id !== null) {
            $formParams['parent_id'] = ObjectSerializer::toFormValue($parent_id);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('OTCSTicket');
        if ($apiKey !== null) {
            $headers['OTCSTicket'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addVersion
     *
     * @param  string $id The node id (required)
     * @param  \SplFileObject $file The file (required)
     * @param  string $description description (optional)
     * @param  bool $add_major_version Add major version (optional)
     * @param  \DateTime $external_create_date The creation date (optional)
     * @param  \DateTime $external_modify_date The external modification date (optional)
     * @param  string $external_source The external source (optional)
     * @param  string $external_identity The external identity (optional)
     * @param  string $external_identity_type The external identity type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\NewVersionInfo
     */
    public function addVersion($id, $file, $description = null, $add_major_version = null, $external_create_date = null, $external_modify_date = null, $external_source = null, $external_identity = null, $external_identity_type = null)
    {
        list($response) = $this->addVersionWithHttpInfo($id, $file, $description, $add_major_version, $external_create_date, $external_modify_date, $external_source, $external_identity, $external_identity_type);
        return $response;
    }

    /**
     * Operation addVersionWithHttpInfo
     *
     * @param  string $id The node id (required)
     * @param  \SplFileObject $file The file (required)
     * @param  string $description description (optional)
     * @param  bool $add_major_version Add major version (optional)
     * @param  \DateTime $external_create_date The creation date (optional)
     * @param  \DateTime $external_modify_date The external modification date (optional)
     * @param  string $external_source The external source (optional)
     * @param  string $external_identity The external identity (optional)
     * @param  string $external_identity_type The external identity type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\NewVersionInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function addVersionWithHttpInfo($id, $file, $description = null, $add_major_version = null, $external_create_date = null, $external_modify_date = null, $external_source = null, $external_identity = null, $external_identity_type = null)
    {
        $returnType = '\Swagger\Client\Model\NewVersionInfo';
        $request = $this->addVersionRequest($id, $file, $description, $add_major_version, $external_create_date, $external_modify_date, $external_source, $external_identity, $external_identity_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\NewVersionInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addVersionAsync
     *
     * 
     *
     * @param  string $id The node id (required)
     * @param  \SplFileObject $file The file (required)
     * @param  string $description description (optional)
     * @param  bool $add_major_version Add major version (optional)
     * @param  \DateTime $external_create_date The creation date (optional)
     * @param  \DateTime $external_modify_date The external modification date (optional)
     * @param  string $external_source The external source (optional)
     * @param  string $external_identity The external identity (optional)
     * @param  string $external_identity_type The external identity type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addVersionAsync($id, $file, $description = null, $add_major_version = null, $external_create_date = null, $external_modify_date = null, $external_source = null, $external_identity = null, $external_identity_type = null)
    {
        return $this->addVersionAsyncWithHttpInfo($id, $file, $description, $add_major_version, $external_create_date, $external_modify_date, $external_source, $external_identity, $external_identity_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addVersionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The node id (required)
     * @param  \SplFileObject $file The file (required)
     * @param  string $description description (optional)
     * @param  bool $add_major_version Add major version (optional)
     * @param  \DateTime $external_create_date The creation date (optional)
     * @param  \DateTime $external_modify_date The external modification date (optional)
     * @param  string $external_source The external source (optional)
     * @param  string $external_identity The external identity (optional)
     * @param  string $external_identity_type The external identity type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addVersionAsyncWithHttpInfo($id, $file, $description = null, $add_major_version = null, $external_create_date = null, $external_modify_date = null, $external_source = null, $external_identity = null, $external_identity_type = null)
    {
        $returnType = '\Swagger\Client\Model\NewVersionInfo';
        $request = $this->addVersionRequest($id, $file, $description, $add_major_version, $external_create_date, $external_modify_date, $external_source, $external_identity, $external_identity_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addVersion'
     *
     * @param  string $id The node id (required)
     * @param  \SplFileObject $file The file (required)
     * @param  string $description description (optional)
     * @param  bool $add_major_version Add major version (optional)
     * @param  \DateTime $external_create_date The creation date (optional)
     * @param  \DateTime $external_modify_date The external modification date (optional)
     * @param  string $external_source The external source (optional)
     * @param  string $external_identity The external identity (optional)
     * @param  string $external_identity_type The external identity type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addVersionRequest($id, $file, $description = null, $add_major_version = null, $external_create_date = null, $external_modify_date = null, $external_source = null, $external_identity = null, $external_identity_type = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling addVersion'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling addVersion'
            );
        }

        $resourcePath = '/api/v1/nodes/{id}/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($add_major_version !== null) {
            $queryParams['add_major_version'] = ObjectSerializer::toQueryValue($add_major_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // form params
        if ($external_create_date !== null) {
            $formParams['external_create_date'] = ObjectSerializer::toFormValue($external_create_date);
        }
        // form params
        if ($external_modify_date !== null) {
            $formParams['external_modify_date'] = ObjectSerializer::toFormValue($external_modify_date);
        }
        // form params
        if ($external_source !== null) {
            $formParams['external_source'] = ObjectSerializer::toFormValue($external_source);
        }
        // form params
        if ($external_identity !== null) {
            $formParams['external_identity'] = ObjectSerializer::toFormValue($external_identity);
        }
        // form params
        if ($external_identity_type !== null) {
            $formParams['external_identity_type'] = ObjectSerializer::toFormValue($external_identity_type);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('OTCSTicket');
        if ($apiKey !== null) {
            $headers['OTCSTicket'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV1AuthGet
     *
     * Gets information on the currently authenticated user.
     *
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (optional)
     * @param  bool $perspective Determines if the landing page perspective will be included in the response. (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;.  The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not).  This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiV1AuthGet($fields = null, $expand = null, $expand_fields = null, $perspective = null, $suppress_response_codes = null)
    {
        $this->apiV1AuthGetWithHttpInfo($fields, $expand, $expand_fields, $perspective, $suppress_response_codes);
    }

    /**
     * Operation apiV1AuthGetWithHttpInfo
     *
     * Gets information on the currently authenticated user.
     *
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (optional)
     * @param  bool $perspective Determines if the landing page perspective will be included in the response. (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;.  The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not).  This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1AuthGetWithHttpInfo($fields = null, $expand = null, $expand_fields = null, $perspective = null, $suppress_response_codes = null)
    {
        $returnType = '';
        $request = $this->apiV1AuthGetRequest($fields, $expand, $expand_fields, $perspective, $suppress_response_codes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiV1AuthGetAsync
     *
     * Gets information on the currently authenticated user.
     *
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (optional)
     * @param  bool $perspective Determines if the landing page perspective will be included in the response. (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;.  The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not).  This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1AuthGetAsync($fields = null, $expand = null, $expand_fields = null, $perspective = null, $suppress_response_codes = null)
    {
        return $this->apiV1AuthGetAsyncWithHttpInfo($fields, $expand, $expand_fields, $perspective, $suppress_response_codes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1AuthGetAsyncWithHttpInfo
     *
     * Gets information on the currently authenticated user.
     *
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (optional)
     * @param  bool $perspective Determines if the landing page perspective will be included in the response. (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;.  The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not).  This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1AuthGetAsyncWithHttpInfo($fields = null, $expand = null, $expand_fields = null, $perspective = null, $suppress_response_codes = null)
    {
        $returnType = '';
        $request = $this->apiV1AuthGetRequest($fields, $expand, $expand_fields, $perspective, $suppress_response_codes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1AuthGet'
     *
     * @param  string $fields Exclude all fields except the one(s) that are specified (e.g. fields&#x3D;data&amp;fields&#x3D;definitions). (optional)
     * @param  string $expand Expand all fields that belong to the specified persona (e.g. expand&#x3D;node&amp;expand&#x3D;member). (optional)
     * @param  string $expand_fields Expand specified field. Note: field must belong to a persona (e.g. expand_fields&#x3D;id&amp;expand_fields&#x3D;owner_user_id). (optional)
     * @param  bool $perspective Determines if the landing page perspective will be included in the response. (optional)
     * @param  bool $suppress_response_codes Forces the server to always return a HTTP Response of &#39;200 OK&#39;.  The data returned from the call will have an additional integer feature named &#39;statusCode&#39;, which will contain the actual status code (the &#39;statusCode&#39; feature will be added regardless of whether the REST API call was successful or not).  This is an empty parameter, thus no value is required (e.g. ?suppress_response_codes). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV1AuthGetRequest($fields = null, $expand = null, $expand_fields = null, $perspective = null, $suppress_response_codes = null)
    {

        $resourcePath = '/api/v1/auth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($expand !== null) {
            $queryParams['expand'] = ObjectSerializer::toQueryValue($expand);
        }
        // query params
        if ($expand_fields !== null) {
            $queryParams['expand_fields'] = ObjectSerializer::toQueryValue($expand_fields);
        }
        // query params
        if ($perspective !== null) {
            $queryParams['perspective'] = ObjectSerializer::toQueryValue($perspective);
        }
        // query params
        if ($suppress_response_codes !== null) {
            $queryParams['suppress_response_codes'] = ObjectSerializer::toQueryValue($suppress_response_codes);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV1AuthPost
     *
     * Authenticate user
     *
     * @param  string $username Login name (required)
     * @param  string $password Login password (required)
     * @param  string $domain Login domain (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AuthenticationInfo
     */
    public function apiV1AuthPost($username, $password, $domain)
    {
        list($response) = $this->apiV1AuthPostWithHttpInfo($username, $password, $domain);
        return $response;
    }

    /**
     * Operation apiV1AuthPostWithHttpInfo
     *
     * Authenticate user
     *
     * @param  string $username Login name (required)
     * @param  string $password Login password (required)
     * @param  string $domain Login domain (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AuthenticationInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1AuthPostWithHttpInfo($username, $password, $domain)
    {
        $returnType = '\Swagger\Client\Model\AuthenticationInfo';
        $request = $this->apiV1AuthPostRequest($username, $password, $domain);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AuthenticationInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV1AuthPostAsync
     *
     * Authenticate user
     *
     * @param  string $username Login name (required)
     * @param  string $password Login password (required)
     * @param  string $domain Login domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1AuthPostAsync($username, $password, $domain)
    {
        return $this->apiV1AuthPostAsyncWithHttpInfo($username, $password, $domain)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1AuthPostAsyncWithHttpInfo
     *
     * Authenticate user
     *
     * @param  string $username Login name (required)
     * @param  string $password Login password (required)
     * @param  string $domain Login domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1AuthPostAsyncWithHttpInfo($username, $password, $domain)
    {
        $returnType = '\Swagger\Client\Model\AuthenticationInfo';
        $request = $this->apiV1AuthPostRequest($username, $password, $domain);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1AuthPost'
     *
     * @param  string $username Login name (required)
     * @param  string $password Login password (required)
     * @param  string $domain Login domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV1AuthPostRequest($username, $password, $domain)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling apiV1AuthPost'
            );
        }
        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling apiV1AuthPost'
            );
        }
        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling apiV1AuthPost'
            );
        }

        $resourcePath = '/api/v1/auth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($username !== null) {
            $formParams['username'] = ObjectSerializer::toFormValue($username);
        }
        // form params
        if ($password !== null) {
            $formParams['password'] = ObjectSerializer::toFormValue($password);
        }
        // form params
        if ($domain !== null) {
            $formParams['domain'] = ObjectSerializer::toFormValue($domain);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCategory
     *
     * Get category info
     *
     * @param  string $id Node ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CategoriesInfo
     */
    public function getCategory($id)
    {
        list($response) = $this->getCategoryWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getCategoryWithHttpInfo
     *
     * Get category info
     *
     * @param  string $id Node ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CategoriesInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCategoryWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\CategoriesInfo';
        $request = $this->getCategoryRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CategoriesInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCategoryAsync
     *
     * Get category info
     *
     * @param  string $id Node ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCategoryAsync($id)
    {
        return $this->getCategoryAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCategoryAsyncWithHttpInfo
     *
     * Get category info
     *
     * @param  string $id Node ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCategoryAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\CategoriesInfo';
        $request = $this->getCategoryRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCategory'
     *
     * @param  string $id Node ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCategoryRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCategory'
            );
        }

        $resourcePath = '/api/v1/nodes/{id}/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('OTCSTicket');
        if ($apiKey !== null) {
            $headers['OTCSTicket'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNode
     *
     * @param  string $id Node ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\V2ResponseElement
     */
    public function getNode($id)
    {
        list($response) = $this->getNodeWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getNodeWithHttpInfo
     *
     * @param  string $id Node ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\V2ResponseElement, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNodeWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\V2ResponseElement';
        $request = $this->getNodeRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\V2ResponseElement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNodeAsync
     *
     * 
     *
     * @param  string $id Node ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAsync($id)
    {
        return $this->getNodeAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNodeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id Node ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNodeAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\V2ResponseElement';
        $request = $this->getNodeRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNode'
     *
     * @param  string $id Node ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNodeRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getNode'
            );
        }

        $resourcePath = '/api/v2/nodes/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('OTCSTicket');
        if ($apiKey !== null) {
            $headers['OTCSTicket'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVersions
     *
     * Get versions of a specific node.
     *
     * @param  string $id The node id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VersionsInfo
     */
    public function getVersions($id)
    {
        list($response) = $this->getVersionsWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getVersionsWithHttpInfo
     *
     * Get versions of a specific node.
     *
     * @param  string $id The node id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VersionsInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVersionsWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\VersionsInfo';
        $request = $this->getVersionsRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VersionsInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVersionsAsync
     *
     * Get versions of a specific node.
     *
     * @param  string $id The node id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVersionsAsync($id)
    {
        return $this->getVersionsAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVersionsAsyncWithHttpInfo
     *
     * Get versions of a specific node.
     *
     * @param  string $id The node id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVersionsAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\VersionsInfo';
        $request = $this->getVersionsRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVersions'
     *
     * @param  string $id The node id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVersionsRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getVersions'
            );
        }

        $resourcePath = '/api/v1/nodes/{id}/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('OTCSTicket');
        if ($apiKey !== null) {
            $headers['OTCSTicket'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lookupRegions
     *
     * Returns a list of regions.
     *
     * @param  bool $queryable queryable (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RegionInfo
     */
    public function lookupRegions($queryable)
    {
        list($response) = $this->lookupRegionsWithHttpInfo($queryable);
        return $response;
    }

    /**
     * Operation lookupRegionsWithHttpInfo
     *
     * Returns a list of regions.
     *
     * @param  bool $queryable (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RegionInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function lookupRegionsWithHttpInfo($queryable)
    {
        $returnType = '\Swagger\Client\Model\RegionInfo';
        $request = $this->lookupRegionsRequest($queryable);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RegionInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lookupRegionsAsync
     *
     * Returns a list of regions.
     *
     * @param  bool $queryable (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupRegionsAsync($queryable)
    {
        return $this->lookupRegionsAsyncWithHttpInfo($queryable)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lookupRegionsAsyncWithHttpInfo
     *
     * Returns a list of regions.
     *
     * @param  bool $queryable (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupRegionsAsyncWithHttpInfo($queryable)
    {
        $returnType = '\Swagger\Client\Model\RegionInfo';
        $request = $this->lookupRegionsRequest($queryable);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lookupRegions'
     *
     * @param  bool $queryable (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lookupRegionsRequest($queryable)
    {
        // verify the required parameter 'queryable' is set
        if ($queryable === null || (is_array($queryable) && count($queryable) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queryable when calling lookupRegions'
            );
        }

        $resourcePath = '/api/v1/regions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($queryable !== null) {
            $resourcePath = str_replace(
                '{' . 'queryable' . '}',
                ObjectSerializer::toPathValue($queryable),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('OTCSTicket');
        if ($apiKey !== null) {
            $headers['OTCSTicket'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation search
     *
     * Returns search results
     *
     * @param  string $where LQL where clause (complex query mode) e.g. &#39;test or OTSubType: 189&#39;. (required)
     * @param  int $slice ID of slice or list of slices. (optional)
     * @param  string $sort Sort region and direction ( e.g. &#39;desc_OTObjectSize&#39;. Ascending is default if not specified ). (optional)
     * @param  int $page Which page to start returning results from. (optional)
     * @param  int $limit Maximum number of items returned per page. (optional)
     * @param  string[] $select List of regions to return, e.g. { &#39;OTName&#39;,&#39;OTFileSize&#39;, ... } Adding a value in the above list will add a &#39;regions&#39; section in the return response. NOTE: The response structure under &#39;regions&#39; will change depending on the regions used in the query. When not specified the list of regions returned will be those defined in the template or query that was used to run the query. If no template or query is specified, the user&#39;s default template is used. (optional)
     * @param  string[] $options List of options for extra data to return. Available options are: { &#39;featured&#39;, &#39;facets&#39;, &#39;facets_raw&#39;, and &#39;highlight_summaries&#39; }. If &#39;facets&#39; or &#39;facets_raw&#39; are included in the option list, a facet section will be added to the return response. (optional)
     * @param  int $query_id ID of a saved search query. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SearchInfo
     */
    public function search($where, $slice = null, $sort = null, $page = null, $limit = null, $select = null, $options = null, $query_id = null)
    {
        list($response) = $this->searchWithHttpInfo($where, $slice, $sort, $page, $limit, $select, $options, $query_id);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * Returns search results
     *
     * @param  string $where LQL where clause (complex query mode) e.g. &#39;test or OTSubType: 189&#39;. (required)
     * @param  int $slice ID of slice or list of slices. (optional)
     * @param  string $sort Sort region and direction ( e.g. &#39;desc_OTObjectSize&#39;. Ascending is default if not specified ). (optional)
     * @param  int $page Which page to start returning results from. (optional)
     * @param  int $limit Maximum number of items returned per page. (optional)
     * @param  string[] $select List of regions to return, e.g. { &#39;OTName&#39;,&#39;OTFileSize&#39;, ... } Adding a value in the above list will add a &#39;regions&#39; section in the return response. NOTE: The response structure under &#39;regions&#39; will change depending on the regions used in the query. When not specified the list of regions returned will be those defined in the template or query that was used to run the query. If no template or query is specified, the user&#39;s default template is used. (optional)
     * @param  string[] $options List of options for extra data to return. Available options are: { &#39;featured&#39;, &#39;facets&#39;, &#39;facets_raw&#39;, and &#39;highlight_summaries&#39; }. If &#39;facets&#39; or &#39;facets_raw&#39; are included in the option list, a facet section will be added to the return response. (optional)
     * @param  int $query_id ID of a saved search query. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SearchInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($where, $slice = null, $sort = null, $page = null, $limit = null, $select = null, $options = null, $query_id = null)
    {
        $returnType = '\Swagger\Client\Model\SearchInfo';
        $request = $this->searchRequest($where, $slice, $sort, $page, $limit, $select, $options, $query_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SearchInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAsync
     *
     * Returns search results
     *
     * @param  string $where LQL where clause (complex query mode) e.g. &#39;test or OTSubType: 189&#39;. (required)
     * @param  int $slice ID of slice or list of slices. (optional)
     * @param  string $sort Sort region and direction ( e.g. &#39;desc_OTObjectSize&#39;. Ascending is default if not specified ). (optional)
     * @param  int $page Which page to start returning results from. (optional)
     * @param  int $limit Maximum number of items returned per page. (optional)
     * @param  string[] $select List of regions to return, e.g. { &#39;OTName&#39;,&#39;OTFileSize&#39;, ... } Adding a value in the above list will add a &#39;regions&#39; section in the return response. NOTE: The response structure under &#39;regions&#39; will change depending on the regions used in the query. When not specified the list of regions returned will be those defined in the template or query that was used to run the query. If no template or query is specified, the user&#39;s default template is used. (optional)
     * @param  string[] $options List of options for extra data to return. Available options are: { &#39;featured&#39;, &#39;facets&#39;, &#39;facets_raw&#39;, and &#39;highlight_summaries&#39; }. If &#39;facets&#39; or &#39;facets_raw&#39; are included in the option list, a facet section will be added to the return response. (optional)
     * @param  int $query_id ID of a saved search query. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync($where, $slice = null, $sort = null, $page = null, $limit = null, $select = null, $options = null, $query_id = null)
    {
        return $this->searchAsyncWithHttpInfo($where, $slice, $sort, $page, $limit, $select, $options, $query_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * Returns search results
     *
     * @param  string $where LQL where clause (complex query mode) e.g. &#39;test or OTSubType: 189&#39;. (required)
     * @param  int $slice ID of slice or list of slices. (optional)
     * @param  string $sort Sort region and direction ( e.g. &#39;desc_OTObjectSize&#39;. Ascending is default if not specified ). (optional)
     * @param  int $page Which page to start returning results from. (optional)
     * @param  int $limit Maximum number of items returned per page. (optional)
     * @param  string[] $select List of regions to return, e.g. { &#39;OTName&#39;,&#39;OTFileSize&#39;, ... } Adding a value in the above list will add a &#39;regions&#39; section in the return response. NOTE: The response structure under &#39;regions&#39; will change depending on the regions used in the query. When not specified the list of regions returned will be those defined in the template or query that was used to run the query. If no template or query is specified, the user&#39;s default template is used. (optional)
     * @param  string[] $options List of options for extra data to return. Available options are: { &#39;featured&#39;, &#39;facets&#39;, &#39;facets_raw&#39;, and &#39;highlight_summaries&#39; }. If &#39;facets&#39; or &#39;facets_raw&#39; are included in the option list, a facet section will be added to the return response. (optional)
     * @param  int $query_id ID of a saved search query. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsyncWithHttpInfo($where, $slice = null, $sort = null, $page = null, $limit = null, $select = null, $options = null, $query_id = null)
    {
        $returnType = '\Swagger\Client\Model\SearchInfo';
        $request = $this->searchRequest($where, $slice, $sort, $page, $limit, $select, $options, $query_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'search'
     *
     * @param  string $where LQL where clause (complex query mode) e.g. &#39;test or OTSubType: 189&#39;. (required)
     * @param  int $slice ID of slice or list of slices. (optional)
     * @param  string $sort Sort region and direction ( e.g. &#39;desc_OTObjectSize&#39;. Ascending is default if not specified ). (optional)
     * @param  int $page Which page to start returning results from. (optional)
     * @param  int $limit Maximum number of items returned per page. (optional)
     * @param  string[] $select List of regions to return, e.g. { &#39;OTName&#39;,&#39;OTFileSize&#39;, ... } Adding a value in the above list will add a &#39;regions&#39; section in the return response. NOTE: The response structure under &#39;regions&#39; will change depending on the regions used in the query. When not specified the list of regions returned will be those defined in the template or query that was used to run the query. If no template or query is specified, the user&#39;s default template is used. (optional)
     * @param  string[] $options List of options for extra data to return. Available options are: { &#39;featured&#39;, &#39;facets&#39;, &#39;facets_raw&#39;, and &#39;highlight_summaries&#39; }. If &#39;facets&#39; or &#39;facets_raw&#39; are included in the option list, a facet section will be added to the return response. (optional)
     * @param  int $query_id ID of a saved search query. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRequest($where, $slice = null, $sort = null, $page = null, $limit = null, $select = null, $options = null, $query_id = null)
    {
        // verify the required parameter 'where' is set
        if ($where === null || (is_array($where) && count($where) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $where when calling search'
            );
        }

        $resourcePath = '/api/v2/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($where !== null) {
            $formParams['where'] = ObjectSerializer::toFormValue($where);
        }
        // form params
        if ($slice !== null) {
            $formParams['slice'] = ObjectSerializer::toFormValue($slice);
        }
        // form params
        if ($sort !== null) {
            $formParams['sort'] = ObjectSerializer::toFormValue($sort);
        }
        // form params
        if ($page !== null) {
            $formParams['page'] = ObjectSerializer::toFormValue($page);
        }
        // form params
        if ($limit !== null) {
            $formParams['limit'] = ObjectSerializer::toFormValue($limit);
        }
        // form params
        if ($select !== null) {
            $formParams['select'] = ObjectSerializer::toFormValue($select);
        }
        // form params
        if ($options !== null) {
            $formParams['options'] = ObjectSerializer::toFormValue($options);
        }
        // form params
        if ($query_id !== null) {
            $formParams['query_id'] = ObjectSerializer::toFormValue($query_id);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('OTCSTicket');
        if ($apiKey !== null) {
            $headers['OTCSTicket'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
